import { PropertyStore } from '../PropertyStore'; // Assuming path: @/api/properties/PropertyStore.ts
import { NodePropertyValues } from './NodePropertyValues';
import { NodeProperty } from './NodeProperty'; // Assuming this interface exists
import { MemoryEstimation } from '@/mem/MemoryEstimation'; // Placeholder for MemoryEstimation type
import { MemoryEstimations } from '@/mem/MemoryEstimations'; // Placeholder for actual estimations

// Forward declaration for the builder to break circular dependency if builder returns NodePropertyStore
class NodePropertyStoreBuilder {} // Will be fully defined below

/**
 * Represents a store for node properties.
 * Each property is identified by a string key and holds NodePropertyValues.
 * This is a TypeScript equivalent of GDS's org.neo4j.gds.api.properties.nodes.NodePropertyStore.
 */
export interface NodePropertyStore extends PropertyStore<NodePropertyValues, NodeProperty> {
  // NodePropertyStore might have specific methods in the future,
  // but for now, it primarily inherits from PropertyStore.
}

/**
 * Concrete implementation of NodePropertyStore.
 * Instances are typically created via the NodePropertyStoreBuilder.
 */
class ConcreteNodePropertyStore implements NodePropertyStore {
  private readonly _properties: ReadonlyMap<string, NodeProperty>;

  constructor(properties: ReadonlyMap<string, NodeProperty>) {
    this._properties = properties;
  }

  public static empty(): NodePropertyStore {
    return new ConcreteNodePropertyStore(new Map());
  }

  public static builder(): NodePropertyStoreBuilder {
    // Initialize with an empty map as per the Java version's comment
    return new NodePropertyStoreBuilder(new Map());
  }

  hasProperty(propertyKey: string): boolean {
    return this._properties.has(propertyKey);
  }

  property(propertyKey: string): NodeProperty | undefined {
    return this._properties.get(propertyKey);
  }

  properties(): ReadonlyMap<string, NodeProperty> {
    return this._properties;
  }

  propertyValues(propertyKey: string): NodePropertyValues | undefined {
    const prop = this.property(propertyKey);
    return prop?.values(); // Assuming NodeProperty has a values() method
  }

  release(): void {
    this._properties.forEach(prop => prop.values().release()); // Assuming NodePropertyValues has release
  }

  memoryEstimation(): MemoryEstimation {
    let totalEstimation = MemoryEstimations.empty(); // Placeholder
    this._properties.forEach(prop => {
      // Assuming MemoryEstimation has an 'add' or 'plus' method
      // totalEstimation = totalEstimation.plus(prop.values().memoryEstimation());
    });
    // Add estimation for the map structure itself if significant
    return totalEstimation;
  }

  isEmpty(): boolean {
    return this._properties.size === 0;
  }

  count(): number {
    return this._properties.size;
  }
}

/**
 * Builder for creating NodePropertyStore instances.
 * This mirrors the builder pattern used in GDS, often generated by Immutables.org.
 */
export class NodePropertyStoreBuilder {
  // In Java, 'properties' was a field in the Immutables builder.
  // We'll manage it directly here.
  private currentProperties: Map<string, NodeProperty>;

  /**
   * Initializes a new builder.
   * @param initialProperties - Optional initial set of properties.
   */
  constructor(initialProperties?: Map<string, NodeProperty>) {
    this.currentProperties = initialProperties || new Map<string, NodeProperty>();
  }

  /**
   * Sets all properties, replacing any existing ones.
   * @param props A map of property keys to NodeProperty objects.
   * @returns This builder instance for chaining.
   */
  public properties(props: ReadonlyMap<string, NodeProperty>): NodePropertyStoreBuilder {
    this.currentProperties = new Map(props); // Create a mutable copy
    return this;
  }

  /**
   * Adds a property if the key is not already present.
   * @param propertyKey The key of the property.
   * @param nodeProperty The NodeProperty object.
   * @returns This builder instance for chaining.
   */
  public putIfAbsent(propertyKey: string, nodeProperty: NodeProperty): NodePropertyStoreBuilder {
    if (!this.currentProperties.has(propertyKey)) {
      this.currentProperties.set(propertyKey, nodeProperty);
    }
    return this;
  }

  /**
   * Adds a property, replacing it if the key already exists.
   * @param propertyKey The key of the property.
   * @param nodeProperty The NodeProperty object.
   * @returns This builder instance for chaining.
   */
  public put(propertyKey: string, nodeProperty: NodeProperty): NodePropertyStoreBuilder {
    this.currentProperties.set(propertyKey, nodeProperty);
    return this;
  }


  /**
   * Removes a property by its key.
   * @param propertyKey The key of the property to remove.
   * @returns This builder instance for chaining.
   */
  public removeProperty(propertyKey: string): NodePropertyStoreBuilder {
    this.currentProperties.delete(propertyKey);
    return this;
  }

  /**
   * Builds and returns a new NodePropertyStore instance.
   * The returned store will be based on a readonly snapshot of the properties
   * configured in the builder at the time of calling build().
   * @returns A new NodePropertyStore instance.
   */
  public build(): NodePropertyStore {
    // Pass a ReadonlyMap to the ConcreteNodePropertyStore constructor
    return new ConcreteNodePropertyStore(new Map(this.currentProperties));
  }
}

// Export the static methods by assigning them from the implementation
// This makes `NodePropertyStore.empty()` and `NodePropertyStore.builder()` available.
// However, TypeScript interfaces cannot have static methods implemented directly.
// A common pattern is to export a const object or use a namespace/module for these static-like factory methods.

// Alternative way to expose static-like factories:
export const NodePropertyStoreFactory = {
  empty: (): NodePropertyStore => ConcreteNodePropertyStore.empty(),
  builder: (): NodePropertyStoreBuilder => ConcreteNodePropertyStore.builder(),
};

// If you prefer calling NodePropertyStore.empty(), you might do this:
// (This is a bit of a workaround as interfaces don't have static implementations)
// export const NodePropertyStore = {
//   empty: (): NodePropertyStore => ConcreteNodePropertyStore.empty(),
//   builder: (): NodePropertyStoreBuilder => ConcreteNodePropertyStore.builder(),
// };
// And then ensure your interface is named differently, e.g., INodePropertyStore,
// or consumers import the factory object.

// For simplicity and closer match to Java's static method feel, often a namespace is used
// or the class itself (ConcreteNodePropertyStore) is exported if its constructor is public
// and it contains the static methods.

// Given the Java `NodePropertyStore.empty()` and `NodePropertyStore.builder()`,
// the most direct way if `NodePropertyStore` was a class would be static methods on it.
// Since it's an interface, the factory object (`NodePropertyStoreFactory`) is a clean TS pattern.
// Or, you can export the ConcreteNodePropertyStore and use its static methods.
// For this translation, I'll assume users will use `NodePropertyStoreFactory.builder()`.
